{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: Automated Garage Door Remote\n",
        "description: \"A device to help me be certain that I closed the garage door on my way out of the house -- sync'ed with Home Assistant!\"\n",
        "date: \"2025-05-01\"\n",
        "image: AutomatedGarageDoorRemote/CraftingMount.png\n",
        "author: Gaelen Guzman\n",
        "---\n",
        "\n",
        "\n",
        "## Overview\n",
        "\n",
        "My wife and I just moved into a new apartment and we now have a surprising new responsibility: a garage. I imagine that this isn't a problem for most people, but I've *struggled* to close the door a few times as I drive away... and now I have a new-found anxiety that I've left the door open a lot of the time. \n",
        "\n",
        "I thought that maybe I could use one of my ESP32s as a sensor to report the closed/open state of the door so I can check in the middle of the night without getting up. I figured that while I was at it, I may as well automate it such that the door can close itself if left open for too long (**Update: after a few months of the door closing itself chaotically on Madeleine, I've decided this was a bad move -- it now just sends a push notification to let me know if the door has been open too long!**). \n",
        "\n",
        "The original script I wrote to control the door was in pure C++, and was pretty janky. It had an internally-defined timer set to 10 minutes, such that if the door was open for >10 minutes it would close itself. It accepted an input_number from a slider input in Home Assistant which allowed me to manually change the auto-close time, but it would revert to 10 minutes every time the door closed. After a while this got pretty annoying! \n",
        "\n",
        "I was recently able to sit down and set the whole thing up in ESPhome -- something I didn't even know about when I wrote the first iteration. It's insane how much easier it was! \n",
        "\n",
        "## Materials & Components\n",
        "\n",
        "* ESP32-C3 super mini\n",
        "* A cheap garage door remote (make sure it matches signal type of the opener!)\n",
        "* A Hall effect sensor\n",
        "* A spare USB data cable\n",
        "* A little plastic box to house the device and mount it to the wall\n",
        "\n",
        "## Assembly\n",
        "\n",
        "As usual, I forgot to take very many pictures while this was a work in progress...\n",
        "\n",
        "I started this project by trying to find a way to activate the remote with the ESP32. At first I tried using some input pins on the remote PCB (see the picture below), but I couldn't get the signal to work properly with these -- I think because the voltage going into the \"CLK\" pinout wasn't correct. \n",
        "\n",
        ":::{.border}\n",
        "![My first testing board -- not the final wiring schematic](/HobbyEEProjects/AutomatedGarageDoorRemote/InitialTestingSetup.jpeg){group=\"AutomatedGarageDoor\"}\n",
        ":::\n",
        "\n",
        "After some testing with a breadboard, I found that the most reliable way to do this was to add a transistor that could close the activation button using a 3.3 V GPIO output signal. Interestingly, I also noticed that this transistor needed an additional load LED going to the ESP32 ground in order to work -- which I think suggests that the button typically uses a pull-down resistor? \n",
        "\n",
        "My next step was to start testing the WiFi and MQTT connections so that I could get the ESP32 to publish the door state to my HomeAssistant setup -- and to subscribe to a command topic which would allow me to open and close the door on command. I did a lot of testing with the battery removed from the door remote so I didn't open and close the door 10,000x -- instead, I added an extra external button so I could manually trigger the ESP32 to detect an open/close signal. I used the ESP32's on-board RGB LED as a reporter signal of the WiFi/MQTT connection and the trigger signal (note the bright red signal when I push the button in the video below).\n",
        "\n",
        "![An external button triggers the ESP32 to update an \"open\"/\"closed\" boolean which HomeAssistant reads as \"Unlocked\"/\"Locked\". This also works in reverse: triggering a state change in HomeAssistant updates the state onboard the ESP32. However, without an external sensor, the ESP32 has no way to record the real state of the door.](/HobbyEEProjects/AutomatedGarageDoorRemote/HomeAssistantPublishing.mp4){group=\"AutomatedGarageDoor\"}\n",
        "\n",
        "Adding a Hall effect sensor allows me to detect the true state of the door. I wanted this sensor to be on a long cord so I'd have options on where to mount it -- cue me destroying a spare USB-C cable and attaching 3-pin connectors to each end. \n",
        "\n",
        ":::{.border}\n",
        "::: {layout=\"[[1], [1,1]]\"}\n",
        "![The final ESP32/door remote setup, featuring the can used to build the mount.](/HobbyEEProjects/AutomatedGarageDoorRemote/CraftingMount.png){group=\"AutomatedGarageDoor\"}\n",
        "\n",
        "![Definitely not my best work, and it was up on the wall like this for an embarrassingly long time.](/HobbyEEProjects/AutomatedGarageDoorRemote/VitaminRMount.jpg){group=\"AutomatedGarageDoor\"}\n",
        "\n",
        "![A little cleaner! Now the board isn't being suspended from extremely delicate connections that kept breaking! The slightly opaque box also makes the status light look pretty good.](/HobbyEEProjects/AutomatedGarageDoorRemote/VitaminRMount2.jpg){group=\"AutomatedGarageDoor\"}\n",
        "\n",
        ":::\n",
        ":::\n",
        "\n",
        "I next needed to craft a stable mount for this sensor sit close enough to a magnet on the garage door. I thought *very* carefully about my options and decided that an aluminum can would be the perfect source material for this mount. I got out my tin snips, a metal ruler, and some super adhesive mounting tape to build a little mount. I then drilled some holes in order to screw the Hall effect sensor to the mount and fixed the whole thing to the wall close enough to my magnet to be triggered when the door is closed.\n",
        "\n",
        "For a good few months I left this little board dangling from the connection cable leading to the Hall effect sensor -- a truly janky look. I finally took the time to squeeze it into a little plastic box that kind of obscures the jank and now it looks slightly less like a IED hooked up to the door. \n",
        "\n",
        ":::{.border}\n",
        "::: {layout=\"[[1], [1,1]]\"}\n",
        "![](/HobbyEEProjects/AutomatedGarageDoorRemote/JankyWallAttachment.jpg){group=\"AutomatedGarageDoor\"}\n",
        "\n",
        "![](HobbyEEProjects/AutomatedGarageDoorRemote/SlightlyLessJankFinal.jpeg){group=\"AutomatedGarageDoor\"}\n",
        ":::\n",
        ":::\n",
        "\n",
        "\n",
        "## Code\n",
        "\n",
        "**Update, as I wrote above, this code section is now out of date!** This project is my first which has a real connection with the real world. I need to be confident that this little device won't end up spazzing out and opening the garage door while we're away. \n",
        "\n",
        "My ideas for this include: using a GeoFence to disable it when I'm away for some amount of time (i.e. reporting my location to HomeAssistant, and putting it into a hard off state) and not actually giving it any of its own automation ability (I had originally wanted it to automatically trigger the door to close after some amount of time, instead I might have it send a push notification to me via HomeAssistant).\n",
        "\n",
        "I had a fun round of debugging when the sensor got dislodged and the remote got activated every 2 seconds for the 10+ minutes it took for my wife to come down and unplug it following the first time I left the house after installing the device... The solutions were to find a better spot to mount the sensor and to add a 15 second delay after the trigger function to give the door sufficient time to actually close.\n",
        "\n",
        "**New code in ESPhome:* My original iteration was truly too bad to include here. But I'm happy enough with my final product that I can show it off here! Click to unfold if you want a peek at what my yaml looks like. \n",
        "\n",
        "\n",
        "\n",
        "```{yaml}\n",
        "#| code-fold: true\n",
        "esphome:\n",
        "  name: garagedoorcontroller\n",
        "  friendly_name: GarageDoorController\n",
        "\n",
        "esp32:\n",
        "  board: esp32-c3-devkitm-1\n",
        "  framework:\n",
        "    type: arduino\n",
        "\n",
        "# Enable logging\n",
        "logger:\n",
        "\n",
        "# Enable Home Assistant API\n",
        "api:\n",
        "  encryption:\n",
        "    key: !secret garagedoor_api\n",
        "\n",
        "ota:\n",
        "  - platform: esphome\n",
        "    password: !secret garagedoor_ota\n",
        "\n",
        "wifi:\n",
        "  ssid: !secret wifi_ssid\n",
        "  password: !secret wifi_password\n",
        "\n",
        "  manual_ip:\n",
        "    static_ip: !secret garagedoor_ip\n",
        "    gateway: !secret gateway\n",
        "    subnet: !secret subnet\n",
        "\n",
        "  # Enable fallback hotspot (captive portal) in case wifi connection fails\n",
        "  ap:\n",
        "    ssid: !secret garagedoor_ap_ssid\n",
        "    password: !secret garagedoor_ap_password\n",
        "\n",
        "captive_portal:\n",
        "  \n",
        "# Hall effect sensor, reports whether magnet on door is engaged\n",
        "binary_sensor:\n",
        "  - platform: gpio\n",
        "    pin: \n",
        "      number: GPIO5\n",
        "      # inverted: True\n",
        "    name: \"Garage Door Sensor\"\n",
        "    id: garage_door_sensor\n",
        "    device_class: garage_door\n",
        "    on_state:\n",
        "      then:\n",
        "        - if:\n",
        "            condition:\n",
        "              binary_sensor.is_on: garage_door_sensor\n",
        "            then:\n",
        "              - light.turn_on:\n",
        "                  id: status_light\n",
        "                  red: 10%\n",
        "                  green: 0%\n",
        "                  blue: 0%\n",
        "            else:\n",
        "              - light.turn_off: status_light\n",
        "\n",
        "# Status light, only illuminated if the door is open\n",
        "light:\n",
        "  - platform: neopixelbus\n",
        "    type: RGB\n",
        "    pin: GPIO10\n",
        "    variant: ws2812x\n",
        "    num_leds: 1\n",
        "    id: status_light\n",
        "    name: \"Garage Status Light\"\n",
        "    internal: True\n",
        "\n",
        "# The relay pin that triggers the door clicker\n",
        "output:\n",
        "  - platform: gpio\n",
        "    pin: GPIO0\n",
        "    id: garage_relay\n",
        "\n",
        "# As recommended by my friend Britt, a cover is definitely the way to go for this door\n",
        "  # In HA, this allows for an \"open\", \"close\", and \"stop\" command -- allowing the door to be part-way open\n",
        "  # After triggering a change, the Hall effect sensor is queried and returns its state to HA to report the state of the door\n",
        "cover:\n",
        "  - platform: template\n",
        "    name: \"Garage Door\"\n",
        "    id: garage_door\n",
        "    open_action:\n",
        "      - output.turn_on: garage_relay\n",
        "      - light.turn_on:\n",
        "          id: status_light\n",
        "          red: 0%\n",
        "          green: 0%\n",
        "          blue: 100%\n",
        "      - delay: 500ms\n",
        "      - light.turn_off:\n",
        "          id: status_light\n",
        "      - output.turn_off: garage_relay\n",
        "    close_action:\n",
        "      - output.turn_on: garage_relay\n",
        "      - light.turn_on:\n",
        "          id: status_light\n",
        "          red: 0%\n",
        "          green: 0%\n",
        "          blue: 100%\n",
        "      - delay: 500ms\n",
        "      - light.turn_off:\n",
        "          id: status_light\n",
        "      - output.turn_off: garage_relay\n",
        "    stop_action:\n",
        "      - output.turn_on: garage_relay\n",
        "      - light.turn_on:\n",
        "          id: status_light\n",
        "          red: 0%\n",
        "          green: 0%\n",
        "          blue: 100%\n",
        "      - delay: 500ms\n",
        "      - light.turn_off:\n",
        "          id: status_light\n",
        "      - output.turn_off: garage_relay\n",
        "    optimistic: False\n",
        "    assumed_state: False\n",
        "    lambda: |-\n",
        "      if (id(garage_door_sensor).state) {\n",
        "        return COVER_OPEN;\n",
        "      } else {\n",
        "        return COVER_CLOSED;\n",
        "      }\n",
        "\n",
        "```\n",
        "\n",
        "\n",
        "I do feel like the arcane magic of yaml is still very mysterious to me -- like it seems like there's no obvious resources where you can see all the possible options for every type of entity... I have to admit that I had to ask ChatGPT to help me build the right settings for things like the cover, where I just couldn't find clear instructions online. \n",
        "\n",
        "## Home Assistant integration\n",
        "\n",
        "After deciding that the device shouldn't have the authority to close the door on its own, I set up an automation in Home Assistant that logs how long the door has been in the \"open\" state and sends a push notification to my phone. And from the HA app, I can trigger the door to close! No more input_number that you have to adjust every time you want the door open! \n"
      ],
      "id": "94370a73"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "venv-py3.12",
      "language": "python",
      "display_name": "venv-py3.12",
      "path": "/Users/gaelenguzman/Library/Jupyter/kernels/venv-py3.12"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}